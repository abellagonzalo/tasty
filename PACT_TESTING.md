# Contract Testing with Pact

This document explains how to use Pact contract testing in the Tasty application to ensure frontend and backend stay in sync.

## What is Contract Testing?

Contract testing is a technique for testing integration points between services (consumer and provider) by checking each service in isolation to ensure the messages it sends or receives conform to a shared understanding (the "contract").

In our case:
- **Consumer**: Frontend (React app)
- **Provider**: Backend (Express API)

## Why Use Pact?

Traditional integration tests require both services to be running simultaneously, which:
- Is slow and brittle
- Requires complex test environment setup
- Doesn't catch API contract violations until runtime

Pact solves this by:
1. **Consumer tests** define expectations about API responses (the contract)
2. **Provider tests** verify the API can fulfill those expectations
3. Tests run independently and quickly
4. **Breaking changes are caught immediately** - if you change an API endpoint without updating the consumer, the provider verification will fail!

## How It Works

### 1. Consumer Defines Contract (Frontend)

When you run frontend Pact tests, they:
1. Create a mock API server
2. Define expected requests and responses
3. Run tests against the mock
4. Generate a **pact file** (`pact/pacts/tastyfrontend-tastybackend.json`)

This pact file is the "contract" that documents what the frontend expects.

### 2. Provider Verifies Contract (Backend)

When you run backend Pact tests, they:
1. Read the pact file generated by the frontend
2. Start the real backend API
3. Replay each request from the contract
4. Verify the responses match what the frontend expects

**If the backend response doesn't match, the test fails!**

## Running Contract Tests

### Step 1: Run Consumer Tests (Frontend)

Generate the contract by running the consumer tests:

```bash
cd frontend
npm run test:pact
```

This will:
- Run all consumer tests in `src/services/__tests__/api.pact.test.ts`
- Generate a pact file at `frontend/pact/pacts/tastyfrontend-tastybackend.json`
- Exit after completing (no watch mode)

### Step 2: Run Provider Tests (Backend)

Verify the backend fulfills the contract:

```bash
cd backend
npm run test:pact
```

This will:
- Read the pact file from the frontend
- Start the backend API
- Replay all interactions from the contract
- Verify responses match expectations

### Full Workflow

```bash
# 1. Generate the contract (frontend)
cd frontend
npm run test:pact

# 2. Verify the contract (backend)
cd backend
npm run test:pact
```

## When Tests Fail

### Consumer Test Failure

If a consumer test fails, it means:
- Your frontend code isn't correctly using the mock API
- The test expectations are wrong
- Fix the test or frontend code

### Provider Test Failure

**This is the important one!** If a provider test fails:

1. **Backend changed without frontend knowing** - You modified an API endpoint but didn't update the frontend
2. **Frontend expects something backend doesn't provide** - Frontend test assumes a field or behavior that doesn't exist
3. **Type mismatch** - Frontend expects a number but backend returns a string

**Example failure:**

```
Expected status 201 but got 200
Expected response to have field 'createdAt' but it was missing
```

**How to fix:**

1. If backend is correct: Update frontend consumer test to match
2. If frontend is correct: Update backend to provide what's expected
3. Run both test suites again to verify

## Test Coverage

### Frontend Consumer Tests (`frontend/src/services/__tests__/api.pact.test.ts`)

Tests cover all API endpoints:
- ✅ `POST /api/positions` - Create single position
- ✅ `POST /api/positions/batch` - Create multiple positions
- ✅ `GET /api/positions` - Get all positions
- ✅ `GET /api/positions/:id` - Get position by ID
- ✅ `PUT /api/positions/:id` - Update position
- ✅ `DELETE /api/positions/:id` - Delete position
- ✅ Error scenarios (404, 400)

### Backend Provider Tests (`backend/src/__tests__/pact.provider.test.ts`)

Verifies backend can fulfill all consumer expectations using provider states:
- `no positions exist` - Empty state
- `positions exist` - With test data
- `a position with ID test-id-123 exists` - Specific position for GET/PUT/DELETE tests

## CI/CD Integration

To integrate into CI/CD:

```yaml
# Example GitHub Actions workflow
- name: Run consumer tests
  run: cd frontend && npm run test:pact

- name: Run provider verification
  run: cd backend && npm run test:pact
```

**Important:** Run consumer tests before provider tests, as the provider needs the generated pact file.

## Maintaining Tests

### When Adding New Endpoints

1. **Add consumer test** in `frontend/src/services/__tests__/api.pact.test.ts`
   - Define the request and expected response
   - Run `npm run test:pact` to generate updated contract

2. **Add provider state** in `backend/src/__tests__/pact.provider.test.ts` (if needed)
   - Set up any required test data
   - Run `npm run test:pact` to verify

3. **Commit both the test changes and the generated pact file**

### When Changing Existing Endpoints

1. **Update consumer test** to reflect new expectations
2. **Update backend implementation** to match
3. **Run both test suites** to verify compatibility
4. **Commit everything together**

This ensures the contract and code changes are synchronized.

## Benefits

✅ **Catch breaking changes early** - Before they reach production
✅ **Fast feedback** - No need to start both services
✅ **Living documentation** - The pact file documents your API
✅ **Confidence in refactoring** - Change backend knowing frontend expectations are verified
✅ **Type safety across boundaries** - Ensures data structures match

## Troubleshooting

### Pact file not found

**Error:** `Cannot find pact file`

**Solution:** Run consumer tests first to generate the pact file:
```bash
cd frontend && npm run test:pact
```

### Port already in use

**Error:** `Port 8080 already in use` (consumer) or `Port 3001 already in use` (provider)

**Solution:** Stop any running dev servers on those ports

### State handler errors

**Error:** `State handler failed`

**Solution:** Check the provider state handlers in `backend/src/__tests__/pact.provider.test.ts`. Make sure they properly set up/clean up test data.

### Tests pass individually but fail together

**Solution:** Ensure each test properly cleans up state. State handlers should reset data between tests.

## Further Reading

- [Pact Documentation](https://docs.pact.io/)
- [Consumer-Driven Contracts](https://martinfowler.com/articles/consumerDrivenContracts.html)
- [Pact JS Workshop](https://github.com/pact-foundation/pact-workshop-js)

## Questions?

If you're unsure whether a test failure is legitimate:

1. Check the pact file (`frontend/pact/pacts/tastyfrontend-tastybackend.json`) to see what the contract says
2. Check the actual backend response
3. Determine which side is correct and update accordingly
